# Day 016 Notes

## Topic: OOP (Classes, Objects, Methods, Attributes) — Coffee Machine (OOP version)

Today’s work was mainly inside `main.py`. The other files (`menu.py`, `coffee_maker.py`, `money_machine.py`) were provided by the instructor. In `main.py` we used those classes to build the coffee machine program.

Project folder:
- day-016/Cofee Machine In OOP/main.py

---

## 1) Which Classes we used
In `main.py`, we imported 3 classes:

- `Menu` (from `menu.py`)
  - Responsible for available drinks and drink lookup.

- `CoffeeMaker` (from `coffee_maker.py`)
  - Responsible for machine resources (water/milk/coffee), checking resources, and making coffee.

- `MoneyMachine` (from `money_machine.py`)
  - Responsible for handling payments and tracking money/profit.

---

## 2) Objects (Instances) we created
A class is a blueprint. An object is the real usable thing created from the class.

In `main.py` we created objects like this:

- `coffee_maker = CoffeeMaker()`
- `coffee_menu = Menu()`
- `money_machine = MoneyMachine()`

These objects are then used to call methods and access data.

---

## 3) Methods used (functions that belong to an object)
In the program, we call methods using dot notation: `object.method()`.

### Menu methods
- `coffee_menu.get_items()`
  - Returns a string of available items (example: "espresso/latte/cappuccino").
  - We used it to show choices in the input prompt.

- `coffee_menu.find_drink(user_drink)`
  - Takes the user’s choice (string) and returns a “drink object” (MenuItem).
  - Example: if user enters "latte", it returns the MenuItem for latte.

### CoffeeMaker methods
- `coffee_maker.report()`
  - Prints current resources (water, milk, coffee).

- `coffee_maker.is_resource_sufficient(drink)`
  - Checks if resources are enough for the selected drink.
  - Returns True/False.

- `coffee_maker.make_coffee(drink)`
  - Deducts resources and “dispenses” coffee.

### MoneyMachine methods
- `money_machine.report()`
  - Prints current money/profit status.

- `money_machine.make_payment(drink.cost)`
  - Handles coin input/payment logic.
  - Returns True if payment is successful, otherwise False.

---

## 4) Attributes used (data inside an object)
Attributes are variables/data stored inside an object.

In `main.py` we used:
- `drink.cost`

Here, `drink` is the object returned by `coffee_menu.find_drink(user_drink)` and `cost` is its attribute (price).

So this line:
- `money_machine.make_payment(drink.cost)`

means:
- “Take the selected drink’s price and ask the MoneyMachine to process payment for that amount.”

---

## 5) How the main loop works (OOP flow)
1. Keep machine running with `while is_on:`
2. Get menu options from `coffee_menu.get_items()`
3. Take user input:
   - If `off` → stop the machine
   - If `report` → print reports from `coffee_maker` and `money_machine`
   - Else:
     - Convert user choice into a drink object using `coffee_menu.find_drink()`
     - Check resources using `coffee_maker.is_resource_sufficient(drink)`
     - Take payment using `money_machine.make_payment(drink.cost)`
     - If both are True → make coffee using `coffee_maker.make_coffee(drink)`

---

## Key takeaway
OOP helped us split responsibilities:
- Menu handles drink data,
- CoffeeMaker handles resources and making coffee,
- MoneyMachine handles money.

`main.py` acts like the controller that connects all these objects together.