# Day 021 Notes

## Project: Snake Game (Part 2) — Food + Scoreboard + Collisions

Today I extended the Snake game by adding:
- food spawning (random position)
- score tracking (scoreboard)
- snake growth on eating food
- collision detection with walls and tail

Project files (Day 21):
- days/day-021/Snake Game Part 2/main.py
- days/day-021/Snake Game Part 2/snake.py
- days/day-021/Snake Game Part 2/food.py
- days/day-021/Snake Game Part 2/scoreboard.py
- days/day-021/Snake Game Part 2/task.py (lesson notes + inheritance example)

---

## 1) main.py (Game Controller)
In `main.py` I connected all the classes together:

Objects created:
- `snake = Snake()`
- `food = Food()`
- `score = ScoreBoard()`

Keyboard controls:
- `screen.listen()`
- `screen.onkey(snake.up, "Up")`
- `screen.onkey(snake.down, "Down")`
- `screen.onkey(snake.left, "Left")`
- `screen.onkey(snake.right, "Right")`

Game loop:
- Runs while `game_is_on` is True
- Uses `time.sleep(0.1)` to control speed
- Calls `snake.move()` every tick

### Collision with food
Condition used:
- `if snake.head.distance(food) < 15:`

Actions:
- `food.refresh()` (move food to a new random spot)
- `snake.extend()` (increase snake length)
- `score.increase_score()` (update score)

### Collision with wall
Condition used:
- If head goes outside bounds (±280):
  - `xcor() > 280 or xcor() < -280 or ycor() > 280 or ycor() < -280`

Actions:
- Stop game: `game_is_on = False`
- Show game over screen with final score: `score.game_over()`

### Collision with tail
Logic:
- Loop over body segments excluding the head using slicing:
  - `for segment in snake.segments[1:]:`
- If head is too close to any body segment:
  - `if snake.head.distance(segment) < 10:`

Actions:
- Stop game and show final score:
  - `game_is_on = False`
  - `score.game_over()`

---

## 2) snake.py (Snake class — movement + growth)
Constants used:
- STARTING_POSITION = [(0,0), (-20,0), (-40,0)]
- MOVE_DISTANCE = 20
- UP=90, DOWN=270, LEFT=180, RIGHT=0

Attributes:
- `self.segments` (list of Turtle segments)
- `self.head` (first segment)

### create_snake()
- Creates 3 square Turtle segments at STARTING_POSITION
- `penup()` used so it doesn’t draw lines

### move()
Key logic (reverse loop):
- Each segment takes the position of the segment in front of it
- Head moves forward by MOVE_DISTANCE

### Direction methods (up/down/left/right)
- Uses `head.setheading(...)`
- Prevents reversing directly (example: if going UP, cannot go DOWN immediately)

### Growth: add_segment() + extend()
- `extend()` adds a new segment at the position of the last segment
- `add_segment(position)` creates a new Turtle square and appends to segments list

---

## 3) food.py (Class Inheritance)
`Food` is a class that inherits from `Turtle`:
- `class Food(Turtle):`

Why inheritance helps:
- Food becomes a Turtle object automatically, so we can use Turtle methods directly:
  - `.shape()`, `.penup()`, `.goto()`, `.color()`, etc.

Food setup:
- circle shape
- smaller size with `shapesize(stretch_wid=0.5, stretch_len=0.5)`
- color set to blue
- speed fastest

### refresh()
- Chooses random x,y within -280 to 280
- moves food to that location with `goto(x, y)`

---

## 4) scoreboard.py (Scoreboard using Turtle)
`ScoreBoard` also inherits from `Turtle`:
- `class ScoreBoard(Turtle):`

Attributes:
- `self.score` starts at 0

Setup:
- white color
- penup + hideturtle
- position at top center: `(0, 270)`

Methods:
- `update_scoreboard()`
  - clears old text and writes new score
- `increase_score()`
  - increments score and updates display
- `game_over()`
  - clears screen and writes final score at the center

---

## 5) Notes from task.py (Concept)
- Focused on class inheritance idea and using `super().__init__()` to call parent class constructor.
- Connected this concept to how Food/ScoreBoard inherit Turtle.